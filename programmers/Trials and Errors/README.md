# Trials and Errors
### openchat_trial.js
테스트 케이스는 통과했지만, 코드에 엄청난 오류가 있었다. 자료형을 배열 하나만으로 처리하려고 하니까 극심한 성능저하를 겪었다.

create, change를 할 때, 같은 id의 이름을 갱신하는 것이 이 문제의 핵심인데, 배열 하나에 모든 정보를 담는다고 치면, 같은 id를 찾으려고 최악의 경우에 O(n)으로 이름을 갱신할 수 있다. 

이 단점을 보완하기 위해서 message와 id를 담는 배열과, 유저의 정보를 따로 보관하는 Map 자료형을 사용해서 이름을 갱신할 때 O(1)로 처리 하도록 하고, 메세지를 마지막에 뿌려줄 때에는 id를 통해 이름만 가져오도록 하면 내가 범했던 오류를 고칠 수 있었다.

### getCombination.js
조합 알고리즘, 재귀함수 사용했다. 핵심은 현재의 값(고정된 값)을 제외한 뒤의 배열에 대해서 똑같이 조합을 구하는 함수를 다시 콜한 후에 그 앞에 붙여주는 것. 조합은 순서가 상관없으니까, 앞에서 부터 순서대로 조합을 구하면 된다.
```javascript
    const rest = origin.slice(index + 1); // 해당하는 fixed를 제외한 나머지 뒤
```

### getPermutation.js
위의 조합 알고리즘과 같은 구조에, 현재의 값(고정된 값)을 제외한 나머지 배열에 대해서 똑같이 순열을 구하는 함수를 다시 콜한 후에 그 앞에 붙여주는 것이 핵심이다. 한가지 다른점이 있다면 "나머지 배열"을 구할 때에 **순서**를 중요시 여기는 순열의 경우에 다음과 같이 나머지 배열의 모든 값에 대해서 순열을 구해야 한다.
```javascript
    const rest = [...origin.slice(0, index), ...origin.slice(index+1)] // 해당하는 fixed를 제외한 나머지 배열 
```

### getSubsets.js
input으로 들어오는 배열에 대해서 멱집합(부분집합)을 구하는 함수. DFS(Depth First Search) 알고리즘으로 해결할 수 있다.