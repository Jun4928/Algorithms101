# Trials and Errors
### openchat_trial.js
테스트 케이스는 통과했지만, 코드에 엄청난 오류가 있었다. 자료형을 배열 하나만으로 처리하려고 하니까 극심한 성능저하를 겪었다.

create, change를 할 때, 같은 id의 이름을 갱신하는 것이 이 문제의 핵심인데, 배열 하나에 모든 정보를 담는다고 치면, 같은 id를 찾으려고 최악의 경우에 O(n)으로 이름을 갱신할 수 있다. 

이 단점을 보완하기 위해서 message와 id를 담는 배열과, 유저의 정보를 따로 보관하는 Map 자료형을 사용해서 이름을 갱신할 때 O(1)로 처리 하도록 하고, 메세지를 마지막에 뿌려줄 때에는 id를 통해 이름만 가져오도록 하면 내가 범했던 오류를 고칠 수 있었다.

### getCombination.js
조합 알고리즘, 재귀함수 사용했다. 핵심은 현재의 값(고정된 값)을 제외한 뒤의 배열에 대해서 똑같이 조합을 구하는 함수를 다시 콜한 후에 그 앞에 붙여주는 것. 조합은 순서가 상관없으니까, 앞에서 부터 순서대로 조합을 구하면 된다.
```javascript
    const rest = origin.slice(index + 1); // 해당하는 fixed를 제외한 나머지 뒤
```

### getPermutation.js
위의 조합 알고리즘과 같은 구조에, 현재의 값(고정된 값)을 제외한 나머지 배열에 대해서 똑같이 순열을 구하는 함수를 다시 콜한 후에 그 앞에 붙여주는 것이 핵심이다. 한가지 다른점이 있다면 "나머지 배열"을 구할 때에 **순서**를 중요시 여기는 순열의 경우에 다음과 같이 나머지 배열의 모든 값에 대해서 순열을 구해야 한다.
```javascript
    const rest = [...origin.slice(0, index), ...origin.slice(index+1)] // 해당하는 fixed를 제외한 나머지 배열 
```

### getSubsets.js
input으로 들어오는 배열에 대해서 멱집합(부분집합)을 구하는 함수. DFS(Depth First Search) 알고리즘으로 해결할 수 있다.

### thesong.js
전형적인 문자열 처리 문제에 + 다양한 요구사항이 들어간 문제다.
문자열 처리를 정규표현식으로 할 수 있었는데(#이 붙은 코드를 소문자화 하는 것), string -> array 를 거치고 reduce 함수로 하나의 문자처럼 취급하는 코드로 접근했다. 그리고 배열끼리 비교하는 코드를 짰더니 복잡해지고 가독성도 떨어지고 엉망진창인 코드가 되어버림.
실제 연주된 악보코드를 구하는 함수도, repeated, rest를 구한다음에 문자열 처리로 간단하게 풀 수 있었다.
애초에 정규표현식 replace로 # => 소문자화 하는 아이디어를 떠올렸으면, string의 includes 메소드를 통해 쉽게 풀 수 있었던 문제다.

위의 엉망진창 이었던 시도가 => 문자열 변환으로 인해서 가독성 좋은 코드로 변화했다. 
**교훈**: 정규표현식!!!!!!!! 이용하기. 예외가 되는 문자열을 구별해 내는 아이디어 떠올릴 것

### setMethods.js
- 합집합, 교집합, 차집합, 대칭차집합, 상위집합 > 부분집합 여부를 구하는 함수 미리 구현 해 놓기